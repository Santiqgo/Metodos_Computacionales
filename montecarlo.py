# -*- coding: utf-8 -*-
"""montecarlo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16IX93dKwT5dYPuTcSzTo3jTqMcKCR9lS
"""

import numpy as np #se importa las librerias a usar
import scipy.integrate as spl
import matplotlib.pylab as plt

def f(x): #se define la funcion a integrar
    return x**4-35*x-np.sin(x)

x=np.linspace(0,10,101) #limites de integracion con 100 particiones entre ellos

def simpson(x0,x1,x2):#se define el metodo de simpson con el que compararemos las integrales
    return (h/3)*(x0+4*x1+x2)

suma=0
h=x[1]-x[0]
for i in range(0,len(x)-1,2): #se usa el metodo de simpson compuesto para aproximar la integral
    suma+=simpson(f(x[i]),f(x[i+1]),f(x[i+2]))

a=x[0]
b=x[-1]
resta=b-a
N1=10
N2=10**6
N3=10**7
sumat1=0
z1=[]
sumat2=0
z2=[]
sumat3=0
z3=[]

for i in range(N1):
    z1.append(b*np.random.random())
    sumat1+=f(z1[i])
for i in range(N3):
    z3.append(b*np.random.random())
    sumat3+=f(z3[i])
for i in range(N2):
    z2.append(b*np.random.random())
    sumat2+=f(z2[i])  
monte1=resta*sumat1*(1/N1)
monte2=resta*sumat2*(1/N2)
monte3=resta*sumat3*(1/N3)

integral=spl.quad(f,x[0],x[-1])#integral usando librerias,es una tupla donde el primer valor da el resultado de la integral y el segundo es el error de esta
#se grafica la funcion
plt.plot(x,f(x))
plt.show()

"""por la forma de la funcion y el tama√±o del intervalo se observa que el metodo de simpson compuesta no sera tan bueno y seria necesario el uso de cuadratura"""

print (suma,monte1,monte2,monte3,integral[0])#se mostrara los valores de la integral dados por simpson compuesta,metodo de montecarlos y la libreria scipy

"""De los valores observados vemos que el que mejor se aproxima es el del metodo de simpson,se ve como el metodo de monte carlo aproxima mejor al aumentar el numero de elementos aleatorios,lo cual deberia aproximar mejor cuando se toman infinitos elementos."""